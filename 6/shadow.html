<html>
<head>
    <script src="https://threejsfundamentals.org/threejs/resources/threejs/r105/three.min.js"></script>
    <script src="https://threejsfundamentals.org/threejs/resources/threejs/r105/js/controls/OrbitControls.js"></script>
    <script src="https://threejsfundamentals.org/threejs/../3rdparty/dat.gui.min.js"></script>
    <style>
        body{
            margin: 0;
        }
        canvas#c{
            width: 100%;
            height: 100%;
        }
        .split {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            display: flex;
        }
        .split>div {
            width: 100%;
            height:100%;
        }
    </style>
</head>
<body>
    <canvas id="c">
    </canvas>
    <script>
        'use strict';

        function main() {
            const canvas = document.querySelector("#c");
            const renderer = new THREE.WebGLRenderer({canvas});
//            renderer.physicallyCorrectLights = true;
            renderer.shadowMap.enabled = true;

            const gui = new dat.GUI();


            const fov = 75;
            const aspect = 2;
            const near = 0.05;
            const far = 50;
            const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.set(0, 10, 20);
            camera.lookAt(0,0,0);


            const scene = new THREE.Scene();
            scene.background = new THREE.Color('white')

            const controls = new THREE.OrbitControls(camera, canvas);
            controls.target.set(0, 5, 0);
            controls.update();


            const loader = new THREE.TextureLoader();
            {
                const planeSize = 40;
                const texture = loader.load('assets/checker.png')
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.magFilter = THREE.NearestFilter;
                const repeats = planeSize / 2;
                texture.repeat.set(repeats, repeats);

                const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
                const planeMat = new THREE.MeshBasicMaterial({
                    map: texture,
                    side: THREE.DoubleSide
                });
                planeMat.color.setRGB(1.5, 1.5, 1.5);
                const mesh = new THREE.Mesh(planeGeo, planeMat);
                mesh.rotation.x = Math.PI * -.5;
                mesh.receiveShadow = true;
                scene.add(mesh);
            }
            const shadowTexture = loader.load('assets/roundshadow.png');
            const sphereShadowBases = [];

            {
                const sphereRadius = 1;
                const sphereWidthDivisions = 32;
                const sphereHeightDivisions = 16;
                const sphereGeo = new THREE.SphereBufferGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
                const planeSize = 1;
                const shadowGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
                const numSpheres = 15;
                for (let i = 0; i < numSpheres; i ++){
                    const base =  new THREE.Object3D();
                    scene.add(base);

                    const shadowMat = new THREE.MeshBasicMaterial({
                        map: shadowTexture,
                        transparent: true,
                        depthWrite: false
                    });
                    const shadowMesh = new THREE.Mesh(shadowGeo, shadowMat);
                    shadowMesh.position.y = 0.001;
                    shadowMesh.rotation.x = Math.PI * -.5;
                    const shadowSize = sphereRadius * 4;
                    shadowMesh.scale.set(shadowSize, shadowSize, shadowSize);
                    base.add(shadowMesh);

                    const u = i / numSpheres;
                    const sphereMat = new THREE.MeshPhongMaterial();
                    sphereMat.color.setHSL(u, 1, .75);
                    const sphereMesh = new THREE.Mesh(sphereGeo, sphereMat);
                    sphereMesh.position.set(0, sphereRadius + 2, 0);
                    base.add(sphereMesh);

                    sphereShadowBases.push({base, sphereMesh, shadowMesh, y: sphereMesh.position.y});
                }
            }

            {
                const skyColor = 0xB1E1FF;  // light blue
                const groundColor = 0xB97A20;  // brownish orange
                const intensity = 2;
                const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
                scene.add(light);
            }

            {
                const color = 0xFFFFFF;
                const intensity = 1;
                const light = new THREE.DirectionalLight(color, intensity);
                light.castShadow = true;

                light.position.set(0, 10, 5);
                light.target.position.set(-5, 0, 0);
                scene.add(light);
                scene.add(light.target);
            }

            class MinMaxGUIHelper{
                constructor(obj, minProp, maxProp, minDif) {
                    this.obj = obj;
                    this.minProp = minProp;
                    this.maxProp = maxProp;
                    this.minDif = minDif;
                }
                get min() {
                    return this.obj[this.minProp];
                }
                set min(v) {
                    this.obj[this.minProp] = v;
                    this.obj[this.maxProp] = Math.max(this.obj[this.maxProp], v + this.minDif);
                }
                get max() {
                    return this.obj[this.maxProp];
                }
                set max(v) {
                    this.obj[this.maxProp] = v;
                    this.min = this.min;
                }
            }

            function setScissorForElement(elem) {
                const canvasRect = canvas.getBoundingClientRect();
                const elemRect = elem.getBoundingClientRect();
                const right = Math.min(elemRect.right, canvasRect.right) - canvasRect.left;
                const left = Math.max(0, elemRect.left - canvasRect.left);
                const bottom = Math.min(elemRect.bottom, canvasRect.bottom) - canvasRect.top;
                const top = Math.max(0, elemRect.top - canvasRect.top);

                const width = Math.min(canvasRect.width, right - left);
                const height = Math.min(canvasRect.height, bottom - top);

                const positiveYUpBottom = canvasRect.height - bottom;
                renderer.setScissor(left, positiveYUpBottom, width, height);
                renderer.setViewport(left, positiveYUpBottom, width, height);

                return width / height;
            }

            function updateCamera() {
                camera.updateProjectionMatrix();
            }

            //gui.add(camera, 'fov', 1, 180).onChange(updateCamera);
            gui.add(camera, 'fov', 1, 180);
            const minMaxGUIHelper = new MinMaxGUIHelper(camera, 'near', 'far', 0.1);
            //gui.add(minMaxGUIHelper, 'min', 0.1, 50, 0.1).name('near').onChange(updateCamera);
            //gui.add(minMaxGUIHelper, 'max', 0.1, 50, 0.1).name('far').onChange(updateCamera);
            gui.add(minMaxGUIHelper, 'min', 0.05, 50, 0.00001).name('near');
            gui.add(minMaxGUIHelper, 'max', 0.1, 50, 0.1).name('far');

            function resizeRendererToDisplaySize(renderer){
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                const needResize = canvas.width !== width || canvas.height !== height;
                if(needResize){
                    renderer.setSize(width, height, false);
                }
                return needResize
            }
            function render(time){
                time *= 0.001;

                if(resizeRendererToDisplaySize(renderer)){
                    const canvas = renderer.domElement;
                    camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    camera.updateProjectionMatrix();
                }

                sphereShadowBases.forEach((sphereShadowBase, ndx) => {
                    const {base, sphereMesh, shadowMesh, y} = sphereShadowBase;
                    const u = ndx/ sphereShadowBases.length;

                    const speed = time * .2;
                    const angle = speed + u * Math.PI * 2 * (ndx % 1 ? 1: -1);
                    const radius = Math.sin(speed - ndx) * 10;
                    base.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
                    const yOff = Math.abs(Math.sin(time * 2 + ndx));

                    sphereMesh.position.y = y + THREE.Math.lerp(-2, 2, yOff);
                    shadowMesh.material.opacity = THREE.Math.lerp(1, .25, yOff);
                });
                renderer.render(scene, camera);
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }
        main();
    </script>
</body>
</html>
