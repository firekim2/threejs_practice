<html>
<head>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://threejsfundamentals.org/threejs/../3rdparty/dat.gui.min.js"></script>
    <style>
        body{
            margin: 0;
        }
        canvas#c{
            width : 100%;
            height: 100%;
        }
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #loading .progress {
            margin: 1.5em;
            border: 1px solid white;
            width: 50vw;
        }
        #loading .progressbar {
            margin: 2px;
            background: white;
            height: 1em;
            transform-origin: top left;
            transform: scaleX(0);
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <div id="loading">
        <div class="progress">
            <div class="progressbar">

            </div>
        </div>

    </div>
    <script>
        'use strict';

        function main() {
            const canvas = document.querySelector("#c");
            const renderer = new THREE.WebGLRenderer({canvas});

            const fov = 75;
            const aspect = 2;
            const near = 0.1;
            const far = 5;
            const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.z = 2;

            const scene = new THREE.Scene();

            const boxWidth = 1;
            const boxHeight = 1;
            const boxDepth = 1;
            const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

            const cubes = [];
            const loadManager = new THREE.LoadingManager();
            const loader = new THREE.TextureLoader(loadManager);

            /*const material = new THREE.MeshBasicMaterial({
                map: loader.load('assets/wall.jpg'),
            });*/






            const texture = loader.load('assets/wall.jpg');
            const material = new THREE.MeshBasicMaterial({
                map: texture,
            });

/*
            const materials = [
                new THREE.MeshBasicMaterial({map: loader.load('assets/flower-1.jpg')}),
                new THREE.MeshBasicMaterial({map: loader.load('assets/flower-2.jpg')}),
                new THREE.MeshBasicMaterial({map: loader.load('assets/flower-3.jpg')}),
                new THREE.MeshBasicMaterial({map: loader.load('assets/flower-4.jpg')}),
                new THREE.MeshBasicMaterial({map: loader.load('assets/flower-5.jpg')}),
                new THREE.MeshBasicMaterial({map: loader.load('assets/flower-6.jpg')}),
            ]
*/
            const loadingElem = document.querySelector("#loading");
            const progressBarElem = loadingElem.querySelector(".progressbar")

            loadManager.onLoad = () => {
                loadingElem.style.display = 'none';
                const cube = new THREE.Mesh(geometry, material);
                scene.add(cube);
                cubes.push(cube);
            }

            class DegRadHelper {
                constructor(obj, prop) {
                    this.obj = obj;
                    this.prop = prop;
                }
                get value() {
                    return THREE.Math.radToDeg(this.obj[this.prop]);
                }
                set value(v) {
                    this.obj[this.prop] = THREE.Math.degToRad(v);
                }
            }

            class StringToNumberHelper {
                constructor(obj, prop){
                    this.obj = obj;
                    this.prop = prop;
                }
                get value() {
                    return this.obj[this.prop];
                }
                set value(v) {
                    console.log(v)
                    this.obj[this.prop] = parseFloat(v);
                 }
            }


            const wrapModes = {
                'ClamptoEdgeWrapping' : THREE.ClampToEdgeWrapping,
                'RepeatWrapping' : THREE.RepeatWrapping,
                'MirroredRepeatWrapping' : THREE.MirroredRepeatWrapping
            };

            function updateTexture() {
                texture.needsUpdate = true;
            }

            const gui = new dat.GUI();
            gui.add(new StringToNumberHelper(texture, 'wrapS'), 'value', wrapModes).name('texture.wrapS').onChange(updateTexture);
            gui.add(new StringToNumberHelper(texture, 'wrapT'), 'value', wrapModes).name('texture.wrapT').onChange(updateTexture);
            gui.add(texture.repeat, 'x', 0, 5).name('texture.repeat.x');
            gui.add(texture.repeat, 'y', 0, 5).name('texture.repeat.y');
            gui.add(texture.offset, 'x', -2, 2).name('texture.offset.x');
            gui.add(texture.offset, 'y', -2, 2).name('texture.offset.y');
            gui.add(texture.center, 'x', 0.5, 1.5, .01).name('texture.center.x');
            gui.add(texture.center, 'y', 0.5, 1.5, .01).name('texture.center.y');
            gui.add(new DegRadHelper(texture, 'rotation'), 'value', -360, 360).name('texture.rotation');





            loadManager.onProgress = (urlOfLastItemLoaded, itemsLoaded, itemsTotal) => {
                const progress = itemsLoaded / itemsTotal;
                progressBarElem.style.transform = `scaleX(${progress})`;
            }


            function resizeRendererToDisplaySize(renderer){
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                const needResize = canvas.width !== width || canvas.height !== height;
                if (needResize) {
                    renderer.setSize(width, height, false);
                }
                return needResize;
            }

            function render(time){
                time *= 0.001;

                if(resizeRendererToDisplaySize(renderer)){
                    const canvas = renderer.domElement;
                    camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    camera.updateProjectionMatrix();
                }

                cubes.forEach((cube, ndx) => {
                    const speed = 0.2 + ndx * 0.1;
                    const rot = time * speed;
                    cube.rotation.x = rot;
                    cube.rotation.y = rot;
                });

                renderer.render(scene, camera);
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }
        main();
    </script>
</body>
</html>
