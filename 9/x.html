<html>
<head>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://threejsfundamentals.org/threejs/../3rdparty/dat.gui.min.js"></script>
    <script src="https://threejsfundamentals.org/threejs/resources/threejs/r105/js/controls/OrbitControls.js"></script>
    <script src="https://threejsfundamentals.org/threejs/resources/threejs/r105/js/loaders/LoaderSupport.js"></script>
    <script src="https://threejsfundamentals.org/threejs/resources/threejs/r105/js/loaders/OBJLoader2.js"></script>
    <style>
        body{
            margin: 0;
        }
        canvas#c{
            width : 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="webgl2">
        <canvas id="c"></canvas>
    </div>


    <script>
        'use strict';

        var mouse = new THREE.Vector2(), SELECTED;
        var radius = 100, theta = 0;

        function main() {
            var container = document.getElementById( 'webgl2' );

            class ColorGUIHelper {
                constructor(object, prop){
                    this.object = object;
                    this.prop = prop;
                }
                get value(){
                    return `#${this.object[this.prop].getHexString()}`;
                }
                set value(hexString){
                    this.object[this.prop].set(hexString);
                }
            }

            const canvas = document.querySelector("#c");
            const renderer = new THREE.WebGLRenderer({canvas});
            renderer.shadowMap.enabled = true;

            const gui = new dat.GUI();

            const fov = 45;
            const aspect = 2;
            const near = 0.1;
            const far = 1000;
            const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.set(0, 10, 20);

            const camera3 = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera3.position.set(0,200, 0);
            camera3.lookAt(0,0,0);

            const camera2 = new THREE.PerspectiveCamera(fov, aspect, near, far);

            const scene = new THREE.Scene();
            //const cameraHelper = new THREE.CameraHelper(camera2);
            //scene.background = new THREE.Color('black');
            //scene.add(cameraHelper);


            const loadManager = new THREE.LoadingManager();
            const loader = new THREE.TextureLoader(loadManager);
            {
                //plane
                const planeSize = 200;
                const texture = loader.load('assets/checker.png')
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.magFilter = THREE.NearestFilter;
                const repeats = planeSize / 2;
                texture.repeat.set(repeats, repeats);
                const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
                const planeMat = new THREE.MeshPhongMaterial({
                    map: texture,
                    side: THREE.DoubleSide
                });
                const mesh = new THREE.Mesh(planeGeo, planeMat);
                mesh.rotation.x = Math.PI * -.5;
                mesh.receiveShadow = true;
                scene.add(mesh);
            }

            {
                const color = 0xFFFFFF;
                const intensity = 1;
                const light = new THREE.DirectionalLight(0xFFFFFF, intensity);
                light.position.set(0, 20, -5);
                light.target.position.set(-5, 0, 0);
                scene.add(light.target);
                scene.add(light);
                light.castShadow = true;
                light.shadow.mapSize.width = 2048;
                light.shadow.mapSize.height = 2048;

                const d = 50;
                light.shadow.camera.left = -d;
                light.shadow.camera.right = d;
                light.shadow.camera.top = d;
                light.shadow.camera.bottom = -d;
                light.shadow.camera.near = 1;
                light.shadow.camera.far = 50;
                light.shadow.bias = 0.001;

                const sub_light = new THREE.DirectionalLight(0xFFFFFF, intensity * 0.3);
                sub_light.position.set(0, 20, 5);
                sub_light.target.position.set(5, 0, 0);
                sub_light.castShadow = true;
                scene.add(sub_light);
                scene.add(sub_light.target);

                gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('color');
                gui.add(light, 'intensity', 0, 2, 0.01);
                makeXYZGUI(gui, light.position, 'position', updateLight);
                makeXYZGUI(gui, light.target.position, 'target', updateLight);
            }


            const car_object = window.car_object = new THREE.Object3D();
            const tire_object= new THREE.Object3D();

            scene.add(car_object);
            {
                //obj Loader
                var car_temp = []
                var tire_temp = window.tire_temp = []
              const objLoader = new THREE.OBJLoader2();
              objLoader.load('assets/car_test.obj', (object) => {
                 console.log(object)
              })
            }

            function getCenterPoint(mesh) {
                var middle = new THREE.Vector3();
                var geometry = mesh.geometry;

                geometry.computeBoundingBox();

                middle.x = (geometry.boundingBox.max.x + geometry.boundingBox.min.x) / 2;
                middle.y = (geometry.boundingBox.max.y + geometry.boundingBox.min.y) / 2;
                middle.z = (geometry.boundingBox.max.z + geometry.boundingBox.min.z) / 2;

                return middle;
            }

            const camera_follower = new THREE.Object3D();
            car_object.add(camera_follower);


            const raycaster = new THREE.Raycaster();
            container.addEventListener( 'mousemove', onDocumentMouseMove, false );
            container.addEventListener( 'mousedown', onDocumentMouseDown, false );


            const curve = new THREE.SplineCurve( [
               new THREE.Vector2( -80, -80 ),
               new THREE.Vector2( -80, 80 ),
               new THREE.Vector2( 80, 80 ),
               new THREE.Vector2( 80, -80 ),
               new THREE.Vector2( -80, -80 ),
             ] );
             {
                 const points = curve.getPoints( 50 );
                 const geometry = new THREE.BufferGeometry().setFromPoints( points );
                 const material = new THREE.LineBasicMaterial( { color : 0xff0000 } );
                 const splineObject = new THREE.Line( geometry, material );
                 splineObject.rotation.x = Math.PI * .5;
                 splineObject.position.y = 0.05;
                 scene.add(splineObject);
            }
            function frameArea(sizeToFitOnScreen, boxSize, boxCenter, camera) {
                const halfSizeToFitOnScreen = sizeToFitOnScreen * 0.5;
                const halfFovY = THREE.Math.degToRad(camera.fov * .5);
                const distance = halfSizeToFitOnScreen / Math.tan(halfFovY);
                // compute a unit vector that points in the direction the camera is now
                // in the xz plane from the center of the box
                const direction = (new THREE.Vector3())
                  .subVectors(camera.position, boxCenter)
                  .multiply(new THREE.Vector3(1, 0, 1))
                  .normalize();

                // move the camera to a position distance units way from the center
                // in whatever direction the camera was from the center already
                camera.position.copy(direction.multiplyScalar(distance).add(boxCenter));

                // pick some near and far values for the frustum that
                // will contain the box.
                camera.near = boxSize / 100;
                camera.far = boxSize * 100;

                camera.updateProjectionMatrix();

                // point the camera to look at the center of the box
                camera.lookAt(boxCenter.x, boxCenter.y, boxCenter.z);
            }

            function makeXYZGUI(gui, vector3, name, onChangeFn){
                const folder = gui.addFolder(name);
                folder.add(vector3, 'x', -10, 10).onChange(onChangeFn);
                folder.add(vector3, 'z', -10, 10).onChange(onChangeFn);
                folder.add(vector3, 'y', 0, 10).onChange(onChangeFn);
                folder.open();
            }


            function onDocumentMouseMove(event) {
                event.preventDefault();
                mouse.x = event.offsetX * 2 / container.clientWidth - 1;
                mouse.y = -event.offsetY * 2 / container.clientHeight + 1;
            }

            function onDocumentMouseDown(event) {
                event.preventDefault();
                  if ( SELECTED ){
                      console.log(SELECTED)
                      SELECTED.currentHex = 0x00ff00*Math.random();
                      SELECTED.material.emissive.setHex( SELECTED.currentHex );
                  }
            }


            class DegRadHelper {
                constructor(obj, prop){
                    this.obj = obj;
                    this.prop = prop;
                }
                get value() {
                    return THREE.Math.radToDeg(this.obj[this.prop]);
                }
                set value(v) {
                    this.obj[this.prop] = THREE.Math.degToRad(v);
                }
            }

            function updateLight(){

            }

            function resizeRendererToDisplaySize(renderer){
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                const needResize = canvas.width !== width || canvas.height !== height;
                if(needResize){
                    renderer.setSize(width, height, false);
                }
                return needResize
            }

            const targetPosition = new THREE.Vector3();
            const carPosition = new THREE.Vector2();
            const carTarget = new THREE.Vector2();
            const camera_offset = new THREE.Vector3();


            //var gridHelper = new THREE.GridHelper( 0, 0 );
            //car_object.add( gridHelper );
            camera_follower.position.set(0, 5, 10);
            makeXYZGUI(gui, camera_follower.position, 'camera_position', updateLight);


            function render(time){
                time *= 0.00001;
                if(resizeRendererToDisplaySize(renderer)){
                    const canvas = renderer.domElement;
                    camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    camera.updateProjectionMatrix();
                }


                renderer.render(scene, camera2);
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }
        main();
    </script>
</body>
</html>
