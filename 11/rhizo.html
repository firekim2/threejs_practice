<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - buffergeometry - particles</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body{
				margin: 0;
			}
			#container{
				width: 100%;
				height: 100%;
			}
		</style>
		<script src="https://threejs.org/build/three.min.js"></script>
		<script src="https://threejsfundamentals.org/threejs/../3rdparty/dat.gui.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.js"></script>
	</head>
	<body>

		<div id="container"></div>
		<script>
			class ColorGUIHelper {
				constructor(object, prop) {
					this.object = object;
					this.prop = prop;
				}
				get value() {
					return `#${this.object[this.prop].getHexString()}`;
				}
				set value(hexString) {
					this.object[this.prop].set(hexString);
				}
			}

			function makeXYZGUI(gui, vector3, name, onChangeFn) {
				const folder = gui.addFolder(name);
				folder.add(vector3, 'x', -3000, 3000).onChange(onChangeFn);
				folder.add(vector3, 'z', -3000, 3000).onChange(onChangeFn);
				folder.add(vector3, 'y', -3000, 3000).onChange(onChangeFn);
				folder.open();
			}

			const gui = new dat.GUI();
			//gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('color');
		</script>
		

		<script>
			var container;
			var camera, scene, renderer;
			var points;
			init();
			animate();
			function init() {
				container = document.getElementById( 'container' );
				//
				camera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 5, 5000 );
				camera.position.y = 1050;
				camera.position.x = 2400;
				camera.position.z = 2200;
				camera.lookAt(0,0,0);

				makeXYZGUI(gui, camera.position, 'camera_position', onCameraChange);

				function onCameraChange() {
					camera.lookAt(0,0,0);
				}


				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x050505 );
				//scene.fog = new THREE.Fog( 0x050505, 2000, 3500 );
				//

				var width = 120;
				var depth = 120;
				var height = 20;
				var geometry = window.geometry = new THREE.BufferGeometry();
				var positions = [];
				var colors = [];
				var color = new THREE.Color();
				//var n = 1000, n2 = n / 2; // particles spread in the cube
				var len_square = 1200;
				{
					let geometry = new THREE.PlaneGeometry( len_square, len_square );
					let material = new THREE.MeshBasicMaterial( {color: 0x050505, side: THREE.DoubleSide} );
					let plane = new THREE.Mesh( geometry, material );
					let divisions = 16;
					let gridHelper = new THREE.GridHelper( len_square, divisions );
					scene.add( gridHelper );
					plane.rotation.x = Math.PI / 2;
					scene.add( plane );
				}


				for(var i = 0; i < height; i ++){
					for(var j = 0; j < width; j ++){
						var x = len_square / 2;
						var y = - (len_square) / width * i - 0.2;
						var z = (len_square) / width * j - len_square / 2;
						positions.push(x, y, z);
						color.setRGB(100, 100, 100);
						colors.push(color.r, color.g, color.b);

						positions.push(z + len_square / width, y, x);
						colors.push(color.r, color.g, color.b);

						positions.push(z, y, -x);
						colors.push(color.r, color.g, color.b);

						positions.push(- x, y, z + len_square / width);
						colors.push(color.r, color.g, color.b);

					}



				}

				geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
				geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
				geometry.computeBoundingSphere();
				//
				var material = new THREE.PointsMaterial( { size: 15, vertexColors: THREE.VertexColors } );
				points = new THREE.Points( geometry, material );
				scene.add( points );
				//
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );
				//
				//
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			//
			function animate() {
				requestAnimationFrame( animate );
				render();
			}
			function render() {
				var time = Date.now() * 0.001;
				//points.rotation.x = time * 0.25;
				//points.rotation.y = time * 0.5;
				renderer.render( scene, camera );
			}


		</script>

	</body>
</html>
