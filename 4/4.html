<html>
<head>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://threejsfundamentals.org/threejs/../3rdparty/dat.gui.min.js"></script>
    <script src="https://threejsfundamentals.org/threejs/resources/threejs/r105/js/controls/OrbitControls.js"></script>
    <style>
        body{
            margin: 0;
        }
        canvas#c{
            width : 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>

    <script>
        'use strict';

        function main() {
            const canvas = document.querySelector("#c");
            const renderer = new THREE.WebGLRenderer({canvas});

            const gui = new dat.GUI();

            const fov = 45;
            const aspect = 2;
            const near = 0.1;
            const far = 100;
            const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.set(0, 10, 20);

            const scene = new THREE.Scene();

            const controls = new THREE.OrbitControls(camera, canvas);
            controls.target.set(0, 5, 0);
            controls.update();

            const planeSize = 40;
            const loader = new THREE.TextureLoader();
            const texture = loader.load('assets/checker.png')
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.magFilter = THREE.NearestFilter;
            const repeats = planeSize / 2;
            texture.repeat.set(repeats, repeats);

            const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
            const planeMat = new THREE.MeshPhongMaterial({
                map: texture,
                side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(planeGeo, planeMat);
            mesh.rotation.x = Math.PI * -.5;
            scene.add(mesh);

            {
                const cubeSize = 4;
                const cubeGeo = new THREE.BoxBufferGeometry(cubeSize, cubeSize, cubeSize);
                const cubeMat = new THREE.MeshPhongMaterial({color: '#8AC'});
                const mesh = new THREE.Mesh(cubeGeo, cubeMat);
                mesh.position.set(cubeSize + 1, cubeSize / 2, 0);
                scene.add(mesh);
            }
            {
                const sphereRadius = 3;
                const sphereWidthDivisions = 32;
                const sphereHeightDivisions = 16;
                const sphereGeo = new THREE.SphereBufferGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
                const sphereMat = new THREE.MeshPhongMaterial({color: '#CA8'});
                const mesh = new THREE.Mesh(sphereGeo, sphereMat);
                mesh.position.set(-sphereRadius - 1, sphereRadius + 2, 0);
                scene.add(mesh);
            }
            /*
            const color = 0xFFFFFF;
            const intensity = 1;
            const light = new THREE.AmbientLight(color, intensity);
            */
            /*
            const skyColor = 0xB1E1FF;
            const groundColor = 0xB97A20;
            const intensity = 1;
            const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
            */
            /*
            const color = 0xFFFFFF;
            const intensity = 1;
            const light = new THREE.DirectionalLight(color, intensity);
            light.position.set(0, 10, 0);
            light.target.position.set(-5, 0, 0);
            scene.add(light.target);
            */
            /*
            const color = 0xFFFFFF;
            const intensity = 1;
            const light = new THREE.PointLight(color, intensity);
            */
            const color = 0xFFFFFF;
            const intensity = 1;
            const light = new THREE.SpotLight(color, intensity);
            scene.add(light);
            scene.add(light.target);

            //const helper = new THREE.DirectionalLightHelper(light);
            //const helper = new THREE.PointLightHelper(light);
            const helper = new THREE.SpotLightHelper(light);
            scene.add(helper);

            function makeXYZGUI(gui, vector3, name, onChangeFn){
                const folder = gui.addFolder(name);
                folder.add(vector3, 'x', -10, 10).onChange(onChangeFn);
                folder.add(vector3, 'z', -10, 10).onChange(onChangeFn);
                folder.add(vector3, 'y', 0, 10).onChange(onChangeFn);
                folder.open();
            }

            function updateLight() {
                //light.target.updateMatrixWorld();
                helper.update();
            }
            //updateLight();


            class ColorGUIHelper {
                constructor(object, prop){
                    this.object = object;
                    this.prop = prop;
                }
                get value(){
                    return `#${this.object[this.prop].getHexString()}`;
                }
                set value(hexString){
                    this.object[this.prop].set(hexString);
                }
            }

            class DegRadHelper {
                constructor(obj, prop){
                    this.obj = obj;
                    this.prop = prop;
                }
                get value() {
                    return THREE.Math.radToDeg(this.obj[this.prop]);
                }
                set value(v) {
                    this.obj[this.prop] = THREE.Math.degToRad(v);
                }
            }

            //gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('color');
            //gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('skyColor');
            //gui.addColor(new ColorGUIHelper(light, 'groundColor'), 'value').name('groundColor');
            gui.addColor(new ColorGUIHelper(light, 'color'), 'value').name('color');
            gui.add(light, 'intensity', 0, 2, 0.01);
            //gui.add(light, 'distance', 0, 40).onChange(updateLight)
            gui.add(new DegRadHelper(light, 'angle'), 'value', 0, 90).name('angle').onChange(updateLight);
            gui.add(light, 'penumbra', 0, 1, 0.01);
            makeXYZGUI(gui, light.position, 'position', updateLight);
            //makeXYZGUI(gui, light.target.position, 'target', updateLight);

            function resizeRendererToDisplaySize(renderer){
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                const needResize = canvas.width !== width || canvas.height !== height;
                if(needResize){
                    renderer.setSize(width, height, false);
                }
                return needResize
            }
            function render(time){
                time *= 0.001;

                if(resizeRendererToDisplaySize(renderer)){
                    const canvas = renderer.domElement;
                    camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    camera.updateProjectionMatrix();
                }

                renderer.render(scene, camera);
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }
        main();
    </script>
</body>
</html>
