<html>
<head>
    <script src="https://threejsfundamentals.org/threejs/resources/threejs/r105/three.min.js"></script>
    <script src="https://threejsfundamentals.org/threejs/resources/threejs/r105/js/controls/OrbitControls.js"></script>
    <script src="https://threejsfundamentals.org/threejs/../3rdparty/dat.gui.min.js"></script>
    <style>
        body{
            margin: 0;
        }
        canvas#c{
            width: 100%;
            height: 100%;
        }
        .split {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            display: flex;
        }
        .split>div {
            width: 100%;
            height:100%;
        }
    </style>
</head>
<body>
    <canvas id="c">
    </canvas>
    <div class="split">
        <div id="view1" tabindex="1">
        </div>
        <div id="view2" tabindex="2">
        </div>
    </div>
    <script>
        'use strict';

        function main() {
            const canvas = document.querySelector("#c");
            const renderer = new THREE.WebGLRenderer({canvas, logarithmicDepthBuffer: true});
            const gui = new dat.GUI();


            const fov = 75;
            const aspect = 2;
            const near = 0.00001;
            const far = 50;
            const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
            camera.position.set(0, 10, 20);


            const scene = new THREE.Scene();
            const view1Elem = document.querySelector("#view1");
            const view2Elem = document.querySelector("#view2");

            const controls = new THREE.OrbitControls(camera, view1Elem);
            controls.target.set(0, 5, 0);
            controls.update();

            const cameraHelper = new THREE.CameraHelper(camera);
            scene.background = new THREE.Color('black');
            scene.add(cameraHelper);

            const camera2 = new THREE.PerspectiveCamera(60, 2, 0.1, 500);
            camera2.position.set(40, 10, 30);
            camera2.lookAt(0, 5, 0);
            const controls2 = new THREE.OrbitControls(camera2, view2Elem);
            controls2.target.set(0, 5, 0);
            controls2.update();


            const planeSize = 40;
            const loader = new THREE.TextureLoader();
            const texture = loader.load('assets/checker.png')
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.magFilter = THREE.NearestFilter;
            const repeats = planeSize / 2;
            texture.repeat.set(repeats, repeats);

            const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
            const planeMat = new THREE.MeshPhongMaterial({
                map: texture,
                side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(planeGeo, planeMat);
            mesh.rotation.x = Math.PI * -.5;
            scene.add(mesh);
            /*

            {
                const cubeSize = 4;
                const cubeGeo = new THREE.BoxBufferGeometry(cubeSize, cubeSize, cubeSize);
                const cubeMat = new THREE.MeshPhongMaterial({color: '#8AC'});
                const mesh = new THREE.Mesh(cubeGeo, cubeMat);
                mesh.position.set(cubeSize + 1, cubeSize / 2, 0);
                scene.add(mesh);

            }
            {
                const sphereRadius = 3;
                const sphereWidthDivisions = 32;
                const sphereHeightDivisions = 16;
                const sphereGeo = new THREE.SphereBufferGeometry(sphereRadius, sphereWidthDivisions, sphereHeightDivisions);
                const sphereMat = new THREE.MeshPhongMaterial({color: '#CA8'});
                const mesh = new THREE.Mesh(sphereGeo, sphereMat);
                mesh.position.set(-sphereRadius - 1, sphereRadius + 2, 0);
                scene.add(mesh);
            }
            */
            {
                const sphereRadius = 3;
                const sphereWidthDivision = 32;
                const sphereHeightDivision = 16;
                const sphereGeo = new THREE.SphereBufferGeometry(sphereRadius, sphereWidthDivision, sphereHeightDivision);
                const numSphere = 20;
                for (let i = 0; i < numSphere; i++){
                    const sphereMat = new THREE.MeshPhongMaterial();
                    sphereMat.color.setHSL(i * 0.73, 1, 0.5);
                    const mesh = new THREE.Mesh(sphereGeo, sphereMat);
                    mesh.position.set(-sphereRadius - 1, sphereRadius + 2, i * sphereRadius * -2.2);
                    scene.add(mesh);
                }
            }



            {
              const color = 0xFFFFFF;
              const intensity = 1;
              const light = new THREE.DirectionalLight(color, intensity);
              light.position.set(0, 10, 0);
              light.target.position.set(-5, 0, 0);
              scene.add(light);
              scene.add(light.target);
            }

            class MinMaxGUIHelper{
                constructor(obj, minProp, maxProp, minDif) {
                    this.obj = obj;
                    this.minProp = minProp;
                    this.maxProp = maxProp;
                    this.minDif = minDif;
                }
                get min() {
                    return this.obj[this.minProp];
                }
                set min(v) {
                    this.obj[this.minProp] = v;
                    this.obj[this.maxProp] = Math.max(this.obj[this.maxProp], v + this.minDif);
                }
                get max() {
                    return this.obj[this.maxProp];
                }
                set max(v) {
                    this.obj[this.maxProp] = v;
                    this.min = this.min;
                }
            }

            function setScissorForElement(elem) {
                const canvasRect = canvas.getBoundingClientRect();
                const elemRect = elem.getBoundingClientRect();
                const right = Math.min(elemRect.right, canvasRect.right) - canvasRect.left;
                const left = Math.max(0, elemRect.left - canvasRect.left);
                const bottom = Math.min(elemRect.bottom, canvasRect.bottom) - canvasRect.top;
                const top = Math.max(0, elemRect.top - canvasRect.top);

                const width = Math.min(canvasRect.width, right - left);
                const height = Math.min(canvasRect.height, bottom - top);

                const positiveYUpBottom = canvasRect.height - bottom;
                renderer.setScissor(left, positiveYUpBottom, width, height);
                renderer.setViewport(left, positiveYUpBottom, width, height);

                return width / height;
            }

            function updateCamera() {
                camera.updateProjectionMatrix();
            }

            //gui.add(camera, 'fov', 1, 180).onChange(updateCamera);
            gui.add(camera, 'fov', 1, 180);
            const minMaxGUIHelper = new MinMaxGUIHelper(camera, 'near', 'far', 0.1);
            //gui.add(minMaxGUIHelper, 'min', 0.1, 50, 0.1).name('near').onChange(updateCamera);
            //gui.add(minMaxGUIHelper, 'max', 0.1, 50, 0.1).name('far').onChange(updateCamera);
            gui.add(minMaxGUIHelper, 'min', 0.00001, 50, 0.00001).name('near');
            gui.add(minMaxGUIHelper, 'max', 0.1, 50, 0.1).name('far');

            function resizeRendererToDisplaySize(renderer){
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                const needResize = canvas.width !== width || canvas.height !== height;
                if(needResize){
                    renderer.setSize(width, height, false);
                }
                return needResize
            }
            function render(time){
                time *= 0.001;

                /*if(resizeRendererToDisplaySize(renderer)){
                    const canvas = renderer.domElement;
                    camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    camera.updateProjectionMatrix();
                }*/
                renderer.setScissorTest(true);

                resizeRendererToDisplaySize(renderer);
                {
                    const aspect = setScissorForElement(view1Elem);
                    camera.aspect = aspect;
                    camera.updateProjectionMatrix();
                    cameraHelper.update();
                    cameraHelper.visible = false;
                    scene.background.set(0x000000);
                    renderer.render(scene, camera);
                }
                {
                    const aspect = setScissorForElement(view2Elem);
                    camera2.aspect = aspect;
                    camera2.updateProjectionMatrix();
                    cameraHelper.visible = true;
                    scene.background.set(0x000040);
                    renderer.render(scene, camera2);
                }
                //renderer.render(scene, camera);
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }
        main();
    </script>
</body>
</html>
